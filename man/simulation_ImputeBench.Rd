% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulation_ImputeBench.R
\name{simulation_ImputeBench}
\alias{simulation_ImputeBench}
\title{Benchmarking Imputation Methods on Simulated Data}
\usage{
simulation_ImputeBench(
  methods = NULL,
  training = NULL,
  data_parameters = NULL,
  missingness_parameters = NULL,
  repetitions = 5,
  default_methods = c("knn", "MICE", "missF", "softImpute"),
  baseline_method = "median",
  error_measure = "l2",
  scaling_robust = 0.01,
  retrain_always = FALSE,
  verbose = FALSE,
  seed = NULL,
  max_time = 2592000,
  output_data = TRUE
)
}
\arguments{
\item{methods}{A list of functions, taking as an input a numeric matrix with missing entries via an argument \code{data} and a list of
parameters via an argument \code{args}. Default is \code{NULL}, i.e. no additional methods added to the benchmarking.}

\item{training}{A list of functions - which need to be of the same length as the \code{methods} list -, that take as an input
a data matrix with missing entries via an argument \code{data} and outputs the parameters for the respective method via as a list \code{args}.
Default is \code{NULL}.}

\item{data_parameters}{A (named) list of named lists of data parameters, for details see below and the accompanying vignette.
Default is \code{NULL}.}

\item{missingness_parameters}{A (named) list of named lists of parameters defining the way missingness scenarios are drawn, for details see below
and the accompanying vignette. Default is \code{NULL}.}

\item{repetitions}{Integer determining how often an additional missingness pattern according to one entry of \code{scenarios} or  \code{missingness_parameters}
is drawn. Default is \code{5}.}

\item{default_methods}{\code{NULL} or vector with four possible character string entries: \code{"knn"}, \code{"MICE"}, \code{"missF"} and \code{"softImpute"}. Determines
which default imputation method is included in the comparison. Default is \code{c("knn","MICE","missF","softImpute")}.}

\item{baseline_method}{Character string, either \code{"median"} (default) or \code{"mean"}. Defining the baseline imputation method.}

\item{error_measure}{Character string that must be \code{"l2"} (up to now only error measure supported). Default is \code{"l2"}.}

\item{scaling_robust}{Positive numeric, robustness parameter avoiding division by close to zero when the columns are scaled by the standard deviation
when computing the imputation error. Default is \code{0.01}.}

\item{retrain_always}{Boolean, should parameters for each imputation method be learned for every run or only every scenario/parameter choice?
Default is \code{FALSE}.}

\item{verbose}{Boolean, determines if an output to the console is made each time a run is finished. Default is \code{FALSE}.}

\item{seed}{Integer or \code{NULL}, sets a seed. Default is \code{NULL}.}

\item{max_time}{The maximal amount of seconds an imputation method is allowed to take. Default is \code{2592000}, i.e. 30 days.}

\item{output_data}{Boolean, should additional data be collected, i.e. drawn missingness pattern? Default is \code{TRUE}.}
}
\value{
A list is returned by \code{simulation_ImputeBench()} with one or two entries. The first is \verb{$evaluation}
under which one finds a data frame listing imputation performance per run and method and which can be plugged into
\code{plot_ImputeBench()} for a plot of performance. The second entry is included if \code{output_data = TRUE} and is called \verb{$data.list}.
One can find here all drawn data matrices, missingness pattern and all trained parameter of the imputation methods, for details
see the vignette.
}
\description{
Simulation Study to compare imputation methods on simulated data and missingness pattern according to the
benchmarking protocol of RMTBM22.
}
\details{
This function benchmarks imputation methods on simulated data. A detailed description of the functionality and
arguments of \code{simulation_ImputeBench()} can be found in the accompanying vignette. For the exact definition of the benchmarking
protocol and the data and missingness pattern simulation protocols we refer to the paper RMTBM22, see below.
In the following a brief overview over the arguments and example inputs.
\subsection{Customizing the Compared Imputation Methods}{

To add to the default imputation methods user specified ones \code{simulation_ImputeBench()} provides the argument \code{methods} which
expects a list of functions to be passed. These functions have to have exactly two inputs: \code{data} (a numeric matrix with missing
entries denoted by \code{NA}) and \code{args} (a list with parameters for the imputation method, this can be left \code{NULL}). The output
needs to be a numeric matrix without missing entries (by default still missing entries are filled by the baseline imputation
method). For details see the accompanying vignette. Customizing names of the additional methods is done by naming list entries.

Example of \code{methods}:\preformatted{methods = list("Random Imputation" =  function(data,
                         args = NULL)\{
    clms.with.missing.entries =
       which(matrixStats::colSums2(matrix(as.numeric(is.na(data)), nrow = nrow(data))) != 0)
    imputed.matrix = data
    for(t in clms.with.missing.entries)\{
       imputed.matrix[is.na(data[,t]),t] =
       sample(data[!is.na(data[,t]),t], replace = TRUE, size = sum(as.numeric(is.na(data[,t]))))
    \}
    return(imputed.matrix)
  \},
                "User Candidate 2" = function(data, args = ...)\{ ... return(imputed.matrix)\})
}

Via the argument \code{training} parameter training functions can be passed to \code{simulation_ImputeBench()} (note, that this is necessary
if methods are added via \code{methods} which do not except \code{args = NULL} as an input). The argument \code{training} expects as an
input similar to \code{methods} a list of functions, which take as an input only one argument \code{data} and which output the argumnet
\code{args}, a list of parameter choices. The output of functions included in \code{training} must be compatible with the input \code{args}
of the index-wise corresponding functions in \code{methods}.

Example of \code{training}:\preformatted{methods = list(  function(data)\{
    args = NULL
    return(args)
   \},
                 function(data)\{ ... return(args)\})
}

By default the parameter \code{default_methods} is set to \code{c("knn", "MICE", "missF", "softImpute")} including all four supported
default imputation methods in the benchmarking. To remove the default parameters remove them from the vector and supply the
resulting vector to \code{default_methods} (\code{NULL} in case all default methods should be removed).

By default parameter of the imputation methods are trained (default training is supported for k-nn imputation (\code{k}) and soft
impute (\code{lambda})) once every scenario by the default argument \code{retrain_always = FALSE}. To have parameters being retrained
for every run set \code{retrain_always = TRUE}.

The baseline imputation method is median imputation set via the default \code{baseline_method = "median"}. To switch to the second
supported baseline imputation method pass \code{baseline_method = "mean"} for mean imputation.
}

\subsection{Customizing the Data Simulation Protocol}{

The parameter \code{data_parameters} expects a named list of named lists as an entry. Each list entry represents a choice of data
parameters for the data simulation protocol and must have a specific form as detailed in the accompanying vignette, find an
example also further below. Note, that missing entries in a list of data parameters will lead to default choices (not to an
error(!)). For the default choices we refer again to the vignette.

Example for \code{data_parameters}:\preformatted{data_parameters = list("Default" =  list(data.size = 100,
                                         data.type = c(5,5,5,5,5,5),
                                         data.shape = list(gauss.mean = c(0,1),
                                                           gauss.sd = c(1,2),
                                                           pois.lambda = c(1),
                                                           binary.limits = c(0.2,0.8),
                                                           t.mean = c(0,1),
                                                           t.limits = c(1,20),
                                                           nl.mean = c(0,1),
                                                           nl.limits = c(10,30),
                                                           nl.freq = c(10,20,15,1),
                                                           sp.points = 5,
                                                           incl.group = 0),
                                         data.groups = 1,
                                         data.groups.distance = c(0.5,1.5),
                                         data.non.linearity = 0,
                                         data.spars = 0.4,
                                         data.low.dim = 5,
                                         data.low.dim.groups = 1,
                                         data.low.dim.parameters = list(trunc.parameter = c(0.5,10,2,0.5),
                                                                        mean = 1,
                                                                        error.std = 0.05)),
                        "Sphere" = list(data.size = 2000,
                                        ata.type = c(10,0,0,0,0,0),
                                        data.low.dim = 3,
                                        data.non.linearity = 1,
                                        data.low.dim.parameters = list(error.std = 0.8)),
                        "Many Groups" = list(data.size = 2000,
                                             data.type = c(10,0,0,0,0,0),
                                             data.low.dim = 5,
                                             data.groups = 8,
                                             data.groups.distance = c(1,5)),
                        "Many Low-Dim Groups" = list(data.size = 2000,
                                                     data.type = c(10,0,0,0,0,0),
                                                     data.low.dim = 1,
                                                     data.low.dim.groups = 10,
                                                     data.low.dim.parameters = list(mean = 6,
                                                                                    error.std = 0.5)),
                        "Poisson non-linear" = list(data.size = 2000,
                                                   data.type = c(0,10,0,0,0,0,0),
                                                   data.low.dim = 2,
                                                   data.non.linearity = 0.6),
                        ...    )
}
}

\subsection{Customizing the Missingness Pattern Simulation Protocol}{

The parameter \code{missingness_parameters} expects a named list of named lists where each list entry is comprised of at least one
and at most three of lists named \code{"MCAR"}, \code{"MAR"} and/or \code{"MNAR"}, which themselves contain the parameters for the respective
missingness mechanisms. Again for more details we refer to the accompanying vignette.

Example for \code{missingness_parameters}:\preformatted{missingness_parameters = list("Parameters 1" = list("MCAR" = list(columns = 1:10,
                                                                  size = 10,
                                                                  probability = 0.25)),
                              "Parameters 2" = list("MCAR" = list(columns = 1:10,
                                                                  size = 10,
                                                                  probability = 0.05),
                                                     "MAR" = list(columns = 2:4,
                                                                  size = 3,
                                                                  size.regressors = c(1,2),
                                                                  probability.upper = 0.9,
                                                                  probability.lower = 0.1,
                                                                  probability.midpoint = c(0.5,0.2)),
                                                      "MNAR" = list(columns = c(5,10),
                                                                    size = 2,
                                                                    probability.upper = 0.05,
                                                                    probability.lower = 0.95,
                                                                    probability.midpoint = c(0.5,0.3))),
                              "Parameters 3" = list("MAR" = list(columns = 6:10,
                                                                 size = 5,
                                                                 size.regressors = c(1,2),
                                                                 probability.upper = 0.9,
                                                                 probability.lower = 0.1,
                                                                 probability.midpoint = c(0.5,0.2)),
                                                    "MNAR" = list(columns = 1:5,
                                                                  size = 5,
                                                                  probability.upper = 0.05,
                                                                  probability.lower = 0.95,
                                                                  probability.midpoint = c(0.5,0.3))),
                              "Parameters 4" = ...                                                      )
}
}

\subsection{Customization of the Benchmarking Protocol}{

At the moment the argument \code{error_measure} can not be changed as only its default \code{"l2"} is supported.

The argument \code{scaling_robust} expects a positive numeric. It prevents division by 0 when scaling with the error by the standard
deviation. Default of \code{scaling_robust} is \code{0.1}.

The argument \code{repetitions}, by default set to \code{5}, controls how imputation performance on a scenario is computed. It expects a
positive integer as an input.
}

\subsection{Technical Arguments}{

If \code{TRUE} the argument \code{verbose} lets the consolue put out a statement after each run of each scenario. Default is \code{FALSE}.

Via \code{seed} one can set a seed for the benchmarking. Consider that this seed is not passed to imputation methods and thus for
methods using randomness such as missForest the benchmarking performance does not need to be the same even if the seeds are
equal.

The parameter \code{max_time}, set by default to \code{2592000} (or 30 days), controls the maximal time which imputation methods are
allowed to compute their results.

The parameter \code{output_data} controls whether additional data (to the benchmarking results) should be stored and returned. Default
is \code{TRUE}. Details on the outputs can be found in the vignette and further below.
}
}
\references{
R. Richter, A. Miloschewski, J.F. Tavares, M.M.B. Breteler, S. Mukherjee (2012), Benchmarking Single
Imputation Methods. in preparation.
}
\seealso{
\code{data_ImputeBench}, \code{plot_ImputeBench}, \code{missingness_scenario_from_parameters}, \code{simulate_mask}, \code{simulate_data}
}
